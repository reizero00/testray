'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('metal');

var _ReadingProgress = require('./ReadingProgress.soy');

var _ReadingProgress2 = _interopRequireDefault(_ReadingProgress);

var _metalComponent = require('metal-component');

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _ReadingProgressTracker = require('./ReadingProgressTracker');

var _ReadingProgressTracker2 = _interopRequireDefault(_ReadingProgressTracker);

var _metalSoy = require('metal-soy');

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This components renders a list of links to contents on the page. These links
 * show the reading progress for these contents, as well as the expected time
 * for reading them.
 */
var ReadingProgress = function (_Component) {
	_inherits(ReadingProgress, _Component);

	function ReadingProgress() {
		_classCallCheck(this, ReadingProgress);

		return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	/**
  * @inheritDoc
  */
	ReadingProgress.prototype.disposed = function disposed() {
		this.tracker_ && this.tracker_.dispose();
	};

	/**
  * Generates any data that is missing from the given item config object.
  * @param {!Object}
  */


	ReadingProgress.prototype.generateItemMissingData_ = function generateItemMissingData_(item) {
		if (item.href[0] !== '#') {
			// We only generate data for items that use hash links, since we use
			// the contents of the referenced element for that.
			return;
		}

		var element = document.getElementById(item.href.substr(1));
		if (!item.title) {
			item.title = element.querySelector(this.titleSelector).textContent;
		}
		if (!item.time) {
			var charCount = element.textContent.length;
			item.time = Math.round(charCount * 60 / 1500); // Assumes 1500 chars/min
		}
	};

	/**
  * Gets the `ReadingProgressTracker` instance being used.
  * @return {ReadingProgressTracker}
  */


	ReadingProgress.prototype.getTracker = function getTracker() {
		return this.tracker_;
	};

	/**
  * Handles the `rendered` lifecycle. Creates the `ReadingProgressTracker`
  * instance that will be used to calculate reading progress value used by the
  * ui.
  * @protected
  */


	ReadingProgress.prototype.rendered = function rendered(firstRender) {
		if (firstRender) {
			this.tracker_ = new _ReadingProgressTracker2.default(_metal.object.mixin({
				element: this.element
			}, this.trackerConfig));
			this.tracker_.on('progressChanged', this.updateProgress.bind(this));
			this.updateProgress();
		}
	};

	/**
  * Setter function for the `items` attribute. Converts items to the expected
  * format, generating any info that is not given.
  * @param {!Array<string|!{href: string, title: ?string, time: ?string}>} items
  * @return {!{href: string, title: string, time: string}}
  * @protected
  */


	ReadingProgress.prototype.setterItemsFn_ = function setterItemsFn_(items) {
		for (var i = 0; i < items.length; i++) {
			if (_metal.core.isString(items[i])) {
				items[i] = {
					href: items[i]
				};
			}
			this.generateItemMissingData_(items[i]);
		}
		return items;
	};

	/**
  * Updates the UI according to the new progress value.
  */


	ReadingProgress.prototype.updateProgress = function updateProgress() {
		var activeIndex = this.tracker_.activeIndex;
		if (activeIndex >= 0) {
			var link = this.tracker_.getElementForIndex(activeIndex);
			link.querySelector('circle').setAttribute('stroke-dashoffset', 100 - this.tracker_.progress);
		}
	};

	return ReadingProgress;
}(_metalComponent2.default);

_metalSoy2.default.register(ReadingProgress, _ReadingProgress2.default);

/**
 * `ReadingProgress`'s state configuration.
 */
ReadingProgress.STATE = {
	/**
  * An array of items representing links to the elements in the page that this
  * component should track reading progress for. This can either be an array of
  * href strings, or an object with more specific configuration for each item,
  * as follows:
  *   - href: The link this item refers to.
  *   - title: Optional. The title of the item.
  *   - time: Optional. The expected time, in seconds, for reading this item.
  * Optional info that is not given will be generated by analizyng the contents
  * of the elements that are being linked to.
  * @type {!Array<string|!{href: string, title: ?string, time: ?string}>}
  */
	items: {
		setter: 'setterItemsFn_',
		validator: Array.isArray
	},

	/**
  * The DOM selector to be used for finding the titles to be used by the items,
  * when they're not given via the `items` attribute.
  * @type {string}
  */
	titleSelector: {
		validator: _metal.core.isString,
		value: 'h1'
	},

	/**
  * A configuration object to be used when creating the `ReadingProgressTracker`.
  * @type {Object}
  */
	trackerConfig: {
		validator: _metal.core.isObject,
		writeOnce: true
	}
};

exports.default = ReadingProgress;