'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('metal');

var _metal2 = _interopRequireDefault(_metal);

var _metalDom = require('metal-dom');

var _metalDom2 = _interopRequireDefault(_metalDom);

var _metalScrollspy = require('metal-scrollspy');

var _metalScrollspy2 = _interopRequireDefault(_metalScrollspy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Scrollspy implementation that also tracks the percentage of the text that
 * has already been covered by the scrolling, instead of just marking the one
 * being currently viewed.
 */
var ReadingProgressTracker = function (_Scrollspy) {
	_inherits(ReadingProgressTracker, _Scrollspy);

	function ReadingProgressTracker() {
		_classCallCheck(this, ReadingProgressTracker);

		return _possibleConstructorReturn(this, _Scrollspy.apply(this, arguments));
	}

	/**
  * Initializes the main behavior. This is being overriden instead of the
  * constructor because the events need to be attached before the `Scrollspy`
  * super class init code runs. Unfortunately, it's not possible to reference
  * `this` before calling `super` on ES2015 constructors (compilers like babel
  * throw errors).
  * @override
  */
	ReadingProgressTracker.prototype.init = function init() {
		this.on('activeIndexChanged', this.handleActiveIndexChanged);
		this.on('progressChanged', this.handleProgressChanged);

		_Scrollspy.prototype.init.call(this);
	};

	/**
  * Overrides the original method from `Scrollspy` to also calculate the
  * reading progress of the currently active link.
  */


	ReadingProgressTracker.prototype.checkPosition = function checkPosition() {
		_Scrollspy.prototype.checkPosition.call(this);
		this.updateProgress();
	};

	/**
  * Handles the `activeIndexChanged` event. Removes reading progress information
  * from the previously active link and updates the markup of links according
  * to their completion state.
  * @param {!Object} data
  */


	ReadingProgressTracker.prototype.handleActiveIndexChanged = function handleActiveIndexChanged(data) {
		if (_metal2.default.isDef(data.prevVal) && data.prevVal >= 0) {
			var prevElement = this.getElementForIndex(data.prevVal);
			prevElement.removeAttribute('data-reading-progress');
		}
		this.updateCompleted();
	};

	/**
  * Handles the `progressChanged` event. Updates the `data-reading-progress`
  * attribute of the currently active link.
  * @param {!Object} data
  */


	ReadingProgressTracker.prototype.handleProgressChanged = function handleProgressChanged(data) {
		var element = this.getElementForIndex(this.activeIndex);
		element.setAttribute('data-reading-progress', data.newVal);
		if (data.newVal < 100) {
			_metalDom2.default.removeClasses(element, this.completedClass);
		} else {
			_metalDom2.default.addClasses(element, this.completedClass);
		}
	};

	/**
  * Updates the links with the class specified by the `completedClass`
  * attribute, adding it to the links that have been scrolled through and
  * removing from the links that haven't.
  */


	ReadingProgressTracker.prototype.updateCompleted = function updateCompleted() {
		for (var i = 0; i < this.regions.length; i++) {
			var element = this.resolveElement(this.regions[i].link);
			if (i < this.activeIndex) {
				_metalDom2.default.addClasses(element, this.completedClass);
			} else {
				_metalDom2.default.removeClasses(element, this.completedClass);
			}
		}
	};

	/**
  * Updates the current reading progress value.
  */


	ReadingProgressTracker.prototype.updateProgress = function updateProgress() {
		var index = this.activeIndex;
		if (index >= 0) {
			var region = this.regions[index];
			var position = this.getCurrentPosition();
			var maxBottom = this.getScrollHeight_() + this.offset;
			var bottom = Math.min(maxBottom, region.bottom);
			this.progress = Math.min(100 * (position - region.top) / (bottom - region.top), 100);
		}
	};

	return ReadingProgressTracker;
}(_metalScrollspy2.default);

/**
 * ReadingProgressTracker' state config.
 * @type {!Object}
 */


ReadingProgressTracker.STATE = {
	/**
  * The CSS class that will be added to links that reach 100% percentage.
  * @type {string}
  */
	completedClass: {
		validator: _metal2.default.isString,
		value: 'reading-progress-completed'
	},

	/**
  * The reading progress for the currently active link, in percentage.
  * @type {number}
  */
	progress: {
		validator: _metal2.default.isNumber,
		value: 0
	}
};

exports.default = ReadingProgressTracker;